<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on XStar</title>
    <link>http://example.org/posts/</link>
    <description>Recent content in Posts on XStar</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 17 Mar 2023 16:03:18 +0800</lastBuildDate><atom:link href="http://example.org/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>My First Post</title>
      <link>http://example.org/posts/my-first-post/</link>
      <pubDate>Fri, 17 Mar 2023 16:03:18 +0800</pubDate>
      
      <guid>http://example.org/posts/my-first-post/</guid>
      <description>分治 引入 ​	我们国家有着广阔的土地和众多的人口，为了方便管理，分为了很多省份，每个省又分为很多的市，每个市又分为很多的县，每个县又分为很多的镇，每个镇又分为很多的社区&amp;hellip;&amp;hellip;.
​	然后呢，现在，根据小道消息，某某人感染了病毒，但是我们都不认识他，上级阶层的领导知道了这个消息，他想要快速且高效的知道这个人是谁，所以，他就把这个任务交给每个省的省长，省长又交给市长，市长又交给县长，县长又交给镇长，镇长又交给社区，最终每个社区，进行核酸检测，于是就知道是谁感染了病毒。
​	正是因为这样，上级阶层的领导才能快速知道，并且做出相应的措施，以迅速防止疫情蔓延。
​	倘若，没有这样的管理方式，在茫茫人海中，要想知道是谁感染了病毒，这无异于大海捞针，效率简直不要太低。
概念 ​	分治算法（divide and conquer）的核心思想就是分而治之，把一个复杂问题分成两个或者更多的相同和相似的问题，直到最后问题可以简单的直接求解，原问题的解即是子问题解的合并。
与递归的区别：
分治是一种思想；
递归是一种方法；
分治可以用递归来实现，也可以用循环
分治算法的递归实现中，每一层递归都会涉及这样三个操作：
分解：将原问题分解成一系列子问题； 解决：递归地求解各个子问题，若子问题足够小，则直接求解； 合并：将子问题的结果合并成原问题。 图解 举个例子：给定一个字符串，把它的每个字符都变成大写
可以写循环，或者递归
模板 分治法的一般算法设计模式如下：
int divideConquer(int n) { if (n &amp;lt;= n0) { //n为问题规模 ,n0为可解子问题的规模 解子问题; return (子问题的解); } for (i = 1; i &amp;lt;= k; i++) { //分解成较小的子问题p1,p2,...,pk yi = divideConquer(Pi); //递归解决 } T = MERGE(y1, y2, ...,yk); //合并子问题 return (T);//返回问题的解 } 例题 不修改数组找出重复的数字 题目描述 给定一个长度为 n+1 的数组nums，数组中所有的数均在 1∼n 的范围内，其中 n≥1。</description>
    </item>
    
  </channel>
</rss>
